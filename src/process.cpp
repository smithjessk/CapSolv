/**
 *  @author Jess Smith <smith.jessk@gmail.com>
 *  @copyright 2014 Jess Smith
 *  @license MIT
 *
 *  Runs the complete pipeline on an image specified using a relative path
 *  Pipeline details available in ../README.md
 *
 *  Requires enum.tsv to be present in ./../
*/

/** 
 *  TODO:
 *   Implement better alg. than totalApplied to place exp/sub in right spots
 *   Fully document parsing alg.
 *   Add disambiguation for edge case where to characters start at the same spot
 *       and have the same width
 */


// CapSolv Dependencies
#include "parseRow.h"

// Standard Dependencies
#include <iostream>
#include <stdio.h>
#include <vector>
#include <fstream>

// Armadillo
#include <armadillo>

// OpenCV Dependencies
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/objdetect.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/core/utility.hpp>
#include <opencv2/core/cuda.hpp>
#include <opencv2/ml/ml.hpp>

// Conflicts created on Mat
using namespace cv;
using namespace arma;
using namespace std;

// Looks through the enumeration in enum.tsv and finds the symbol that matches 
// the appropriate number
string FindSymbol(int num) {
    string index = "", symbol = "";
    ifstream infile("../enum.tsv");

    while (infile >> index >> symbol) 
        if (to_string(num) == index) 
            break;

    return symbol;
}

// Applies a threshold that accounts for various intensities
cv::Mat PreProcess(cv::Mat img, bool displayImgs = false) {
    // Initialization
    //cout << "Applying preprocessing" << endl;
    cv::Mat mean;
    cv::Mat stddev;

    // Calculate the mean and standard deviation 
    cv::meanStdDev(img, mean, stddev);

    // Determine lower threshold limit
    double lowerLimit = mean.at<double>(0) - (1.25 * stddev.at<double>(0));

    // Apply that threshold
    cv::threshold(img, img, lowerLimit, 255, cv::THRESH_BINARY);

    // Show the thresholded image
    if (displayImgs) {
        cv::namedWindow("Display Image", cv::WINDOW_NORMAL );
        cv::imshow("Display Image", img);
        waitKey(0);
    }

    cout << endl;
    return img;
}

// Computes a length-64 feature vector representing the gradients of the image
// Built in HOG not used because of size restrictions in place
arma::umat ComputeHOG(cv::Mat img, bool displayImgs = false) {
    //cout << "HOG" << endl;

    // Used to determine how to resize
    double aspectRatio = (double)img.rows / img.cols; 
    double scalingFactor, SZ = 20, bin_n = 16;
    cv::Mat gx, gy, magnitude, angle;

    //cout << "Aspect Ratio: " << aspectRatio << endl;

    // If we stretch to certain sizes, the images become greatly deformed

    if (aspectRatio < 0.75) {
        cv::resize(img, img, cv::Size(64, 16)); // Note that size is cols, rows
        scalingFactor = 0.5;
    } 
    else if (aspectRatio > 2) {
        cv::resize(img, img, cv::Size(16, 64));
        scalingFactor = 2;
    }
    else {
        cv::resize(img, img, cv::Size(32, 32));
        scalingFactor = 1;
    }

    // Display the resized image
    if (displayImgs) {
        cv::namedWindow("Display Image", cv::WINDOW_NORMAL );
        cv::imshow("Display Image", img);
        waitKey(0);
    }

    // Compute Sobel derivatives in the x and y directions
    cv::Sobel(img, gx, CV_32F, 1, 0);
    cv::Sobel(img, gy, CV_32F, 0, 1);

    // Convert the derivatives to polar coordinates 
    cv::cartToPolar(gx, gy, magnitude, angle);

    // Quantized values generated by magnitude, angle, and the number of bins
    arma::umat bins = umat(img.rows, img.cols, fill::zeros);

    for (int i = 0; i < bins.n_rows; i++)
        for (int j = 0; j < bins.n_cols; j++) {
            // Quantize, but first convert to Cartesian
            bins(i, j) = (int) ((bin_n * angle.at<float>(i, j)) / 
                (2 * datum::pi)); // Could be replaced with fancy constructors
        }

    // Result array of length 64
    arma::umat result = umat(64, 1, fill::zeros);

    // Array that holds magnitudes; Note that dimensions depend on scaling 
    // scaling factor defined above
    arma::fmat magCells = fmat(32 * scalingFactor, 32 / scalingFactor, 
    	fill::zeros);

    // Used to indicate starting points for iterating over the magCells
    int rowsIndex = 0, colsIndex = 0;

    for (int index = 0; index < 4; index++) { 
        // Current histogram will be a length-16 vector
        arma::fmat currentHist = fmat(16, 1, fill::zeros);

        // Taking the integers 0, 1, 2, and 3 (mod 2) and their values upon
        // integer divison by 2 gives an easy way to reduce loop usage and 
        // code length
        rowsIndex = (magCells.n_rows / 2) * (index % 2);
        colsIndex = (magCells.n_cols / 2) * (index / 2);

        // Mimics numpy's bincount function with bins as the array,
        // magnitudes as the weights, and at least 16 bins
        for (int i = rowsIndex; i < rowsIndex + (magCells.n_rows / 2); i++) 
            for (int j = colsIndex; j < colsIndex + (magCells.n_cols / 2); j++) 
                currentHist(bins(i, j), 0) +=  magnitude.at<float>(i, j);
    

        // Push the current histogram into the result one
        for (int i = 16 * index; i < 16 * (index + 1); i++) 
            result(i, 0) = currentHist(i % 16, 0);
    }

    return result;
}

// Finds the contours in the thresholded image
vector< arma::umat > AnalyzeContours(cv::Mat img, vector< arma::imat >& parseInfo, 
    bool displayImgs = false) {
    //cout << "Analyzing contours" << endl;
    // Initialization

    float imgArea = img.rows * img.cols;
    vector< vector<Point> > contours;

    // To be returned and passed to SVM
    vector< arma::umat > validContours;

    cv::Mat img1 = img.clone();

    cv::Mat imgMean;
    cv::Mat imgStdDev;
    cv::meanStdDev(img1, imgMean, imgStdDev);

    // Find the contours
    cv::findContours(img, contours, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);

    // Vector to hold the bounding rectangles
    vector<Rect> validRectangles(contours.size());

    // Initialize variables to be used later
    cv::Rect temp;
    float currArea;
    float ratio;
    int counter = 0;
    cv::Mat mask;
    Scalar contourMean;

    // Iterate over contours
    for (int i = 0; i < contours.size(); i++) {
        temp = boundingRect(contours[i]);

        // Caluclate each contour's area
        currArea = temp.width * temp.height;
        ratio = currArea / imgArea;


        // If it's big enough
        if (ratio < 2 && ratio > 0.0003 && currArea >= 400) {
            mask = cv::Mat(img1, temp);
            cv::Mat mask2 = cv::Mat(img, temp);
            contourMean = cv::mean(mask);

            float intensityRatio = contourMean[0] / imgMean.at<double>(0);
            if (intensityRatio < 0.95 && (intensityRatio / currArea < 0.0003) ) {
                validContours.push_back(ComputeHOG(mask, displayImgs));
                //arma::imat tempArr = {-1, temp.x, temp.y, temp.width, temp.height};
                parseInfo.push_back({-1, temp.x, temp.y, temp.width, temp.height, -1});
                counter++;
            } 
        }
    }

    return validContours;
}

// Loads and evaluates the SVM on inputMat
// Predictions are returned in outputMat
cv::Mat Predict(cv::Mat inputMat, cv::Mat outputMat) {
    // Setting up SVM
    CvSVMParams params;
    params.svm_type = CvSVM::C_SVC;
    params.kernel_type = CvSVM::LINEAR;
    params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);

    // Loading
    CvSVM SVM;
    SVM.load("svm_data.dat");

    // Predictions
    SVM.predict(inputMat, outputMat);

    return outputMat;
}

// Compares the x values of the contours' top-left corners
// If those are equal, determine which one ends first and put that first
// Note that both imats should be elements of parseInfo
bool CompareHorizontally(arma::imat a, arma::imat b) {
    if (a[1] == b[1]) {
        return (a[1] + a[3]) < (b[1] + b[3]);
    }
    return a[1] < b[1];
}

// Checks if a contour is in the main row 
bool IsInMainRow(int mainRowStart, int mainRowEnd, int contourStart, int contourEnd, int& diff) {

    // If the contour contains the entire main row, it is in the main row
    if ( (mainRowStart > contourStart) && (mainRowEnd < contourEnd) ) 
        return true;


    if (contourStart < mainRowStart) 
        diff += mainRowStart - contourStart;
    
    if (contourEnd > mainRowEnd) 
        diff += contourEnd - mainRowEnd;

    if (diff > 0.4 * (contourEnd - contourStart))
        return false;

    return true;
}

// Finds the row to which a particular symbol belongs
// Tree-based algorithm
int FindRow(vector<ParseRow>& rows, vector<arma::imat>& parseInfo, int index, 
    vector<string>& result, int& rowCounter, int& totalApplied) {

    string temp = "";
    arma::imat contour = parseInfo[index];

    for (int i = 0; i < rows.size(); i++) {
        int mainDiff = 0;
        arma::ivec bounds = rows[i].GetBoundaries();

        // Check if the symbol is in the main section of the current row
        bool contained = IsInMainRow(bounds[1], bounds[5], contour[2], contour[2] + contour[4], mainDiff);

        if (contained) {
            parseInfo[index][5] = i; // Record that this character is in row i
            //cout << parseInfo[index][0] << endl;
            // Go through the characters and choose those which relate to this
            for (int j = 0; j < parseInfo.size(); j++) {
                if (parseInfo[j][5] == i) {
                    int symbolIndex = static_cast<int>(parseInfo[j][0]);
                    //temp += to_string(parseInfo[j][0]);
                    temp += FindSymbol(symbolIndex);
                    parseInfo[j][5] = -1; // The symbol has been assigned
                }
            }

            // Need to iterate over and close all rows that relate to this
            int indexOfLinked = -1;

            // Need to count how far back to move all of the 'toApply' indices
            int numberChildrenApplied = 0;

            // Iterate over all other rows and see if any were above/below this
            for (int j = 0; j < rows.size(); j++) {
                if (rows[j].GetAboveId() == i) {

                    for (int k = 0; k < parseInfo.size(); k++) {
                        if (parseInfo[k][5] == rows[j].GetId()) {
                            int symbolIndex = static_cast<int>(parseInfo[k][0]);
                            result[ rows[j].GetResultIndex() ] += "^" + FindSymbol(symbolIndex);

                            parseInfo[k][5] = -1;
                            indexOfLinked = j;
                            numberChildrenApplied++;
                        }
                    }
                }
            }

            // Now move them back   
            for (int j = 0; j < rows.size(); j++) 
                rows[j].ChangeResultIndex(-1 * numberChildrenApplied);
            
            totalApplied += numberChildrenApplied;

            if (indexOfLinked != -1) 
                rows.erase(rows.begin() + indexOfLinked);
            
            result.push_back(temp);

            return i;
        }
    }

    // Check if it's above
    for (int i = 0; i < rows.size(); i++) {
        int aboveDiff = 0, belowDiff = 0;

        arma::ivec bounds = rows[i].GetBoundaries();

        bool containedAbove = IsInMainRow(bounds[0], bounds[1], 
            contour[2], contour[2] + contour[4], aboveDiff);
        bool containedBelow = IsInMainRow(bounds[2], bounds[3], 
            contour[2], contour[2] + contour[4], belowDiff);

        if (aboveDiff < belowDiff) {
        // Add a new row with the same above limit
        // but a main row in the middle 1/3 of the previous row's 'above' zone

            rows.push_back( ParseRow(rowCounter, i, -1, bounds[0], 
                (bounds[1] - bounds[0]) / 3, 
                2 * (bounds[1] - bounds[0]) / 3,
                bounds[1], index - 1 - totalApplied
                ) );

            rowCounter++;
            parseInfo[index][5] = rowCounter - 1;

            return rowCounter - 1;
        }
        if (belowDiff < aboveDiff) {
            parseInfo[index][5] = i;

        // TODO: COPY CODE FROM ABOVE
            return i;
        }
    }
}

// Runs the parsing algorithm 
vector<string> Parse(vector<arma::imat>& parseInfo, int numRows) {
    vector<string> result;

    // Sort horizontally from left to right
    sort(parseInfo.begin(), parseInfo.end(), CompareHorizontally); 

    // Compute the middle 1/3 of the image
    // Used later in parsing to determine what is an exponent, etc.
    int mainRowStart = numRows / 3;
    int mainRowEnd = 2 * numRows / 3;

    // Vector of rows for parsing
    vector<ParseRow> rows;
    rows.push_back( {0, -1, -1, 0, mainRowStart, mainRowEnd, numRows, 0});

    // Number of rows that have been created; Used to place strings in result
    int rowCounter = 1;

    // Stopgap measure to ensure exp/sub are applied correctly 
    // TODO: Find a better way alg. to do this
    int totalApplied = 0; 

        // Iterate over things and check if they're in the main row
    for (int i = 0; i < parseInfo.size(); i++) 
        int index = FindRow(rows, parseInfo, i, result, rowCounter, totalApplied);

    // Need to apply checks to the final element
    if (result.size() != parseInfo.size()) {
        for (int i = 0; i < rows.size(); i++) {
            // Iterate over all other rows and see if any were above/below this
            for (int j = 0; j < rows.size(); j++) {

                if (rows[j].GetAboveId() == i) {
                    for (int k = 0; k < parseInfo.size(); k++) {
                        if (parseInfo[k][5] == rows[j].GetId()) {
                            result[rowCounter - 1] += "^" + to_string(parseInfo[k][0]) + " ";
                            parseInfo[k][5] = -1;
                        }
                    }
                }

            } 
        }
    }

    return result;
}

int main(int argc, char** argv) {
    // Why not time the whole thing?
    arma::wall_clock timer;
    timer.tic();

    // Read in the image in grayscale
    cv::Mat image = cv::imread(argv[1], 0);

    // Apply threshold
    cv::Mat threshImage = PreProcess(image, false);

    // Create vector containg location + class info
    // Each element contains these values (in this order): 
    // id, x, y, width, height, row
    // Note that x, y are for the top left corner of the image
    vector< arma::imat > parseInfo;

    // Compute and describe contours
    vector< arma::umat > contours = AnalyzeContours(threshImage, parseInfo, false);

    // Pass the contours into an array of floats
    // Only done to simplify the creation of the inputMat for the SVM
    float contourArray[contours.size()][64];

    for (int i = 0; i < contours.size(); i++)
        for (int j = 0; j < 64; j++)
            contourArray[i][j] = contours[i][j];

    // Create the cv::Mats for the SVM
    cv::Mat inputMat(contours.size(), 64, CV_32FC1, contourArray);
    cv::Mat outputMat(contours.size(), 1, CV_32FC1, 0);

    // Predict using SVM
    outputMat = Predict(inputMat, outputMat);

    // Assign the predictions to their places in the parseInfo vector
    for (int i = 0; i < contours.size(); i++) 
        parseInfo[i][0] = outputMat.at<float>(i, 0);

    // The final string derived from parsing
    // Is a vector b/c this allows easy addition of exponents and subscripts
    vector<string> result = Parse(parseInfo, threshImage.rows);

    // Print the result
    for (int i = 0; i < result.size(); i++) 
        cout << result[i] << " ";
    
    cout << endl;

    // Display time taken
    cout << timer.toc() << endl;

    // End
    return 0;
}