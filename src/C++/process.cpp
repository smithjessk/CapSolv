// Runs the complete pipeline on an image specified using a relative path

// Standard Imports
#include <iostream>
#include <stdio.h>
#include <vector>

// Armadillo
#include <armadillo>

// OpenCV Dependencies
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/objdetect.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/core/utility.hpp>
#include <opencv2/core/cuda.hpp>
#include <opencv2/ml/ml.hpp>

// Conflicts created on Mat
using namespace cv;
using namespace arma;
using namespace std;

// Applies a threshold that accounts for various intensities
cv::Mat preProcess(cv::Mat img, bool displayImgs = false) {
    // Initialization
    cout << "Applying preprocessing" << endl;
    cv::Mat mean;
    cv::Mat stddev;

    // Calculate the mean and standard deviation 
    cv::meanStdDev(img, mean, stddev);
   
    // Determine lower threshold limit
    double lowerLimit = mean.at<double>(0) - (1.25 * stddev.at<double>(0));

    // Apply that threshold
    cv::threshold(img, img, lowerLimit, 255, cv::THRESH_BINARY);

    // Show the thresholded image
    if (displayImgs) {
        cv::namedWindow("Display Image", cv::WINDOW_NORMAL );
        cv::imshow("Display Image", img);
        waitKey(0);
    }

    cout << endl;
    return img;
}

// Computes a length-64 feature vector representing the gradients of the image
// Built in HOG not used because of size restrictions in place
arma::umat ComputeHOG(cv::Mat img, bool displayImgs = false) {
    //cout << "HOG" << endl;

    // Used to determine how to resize
    double aspectRatio = (double)img.rows / img.cols; 
    double scalingFactor, SZ = 20, bin_n = 16;
    cv::Mat gx, gy, magnitude, angle;
    
    //cout << "Aspect Ratio: " << aspectRatio << endl;

    // If we stretch to certain sizes, the images become greatly deformed
    
    if (aspectRatio < 0.75) {
        cv::resize(img, img, cv::Size(64, 16)); // Note that size is cols, rows
        scalingFactor = 0.5;
    } 
    else if (aspectRatio > 2) {
        cv::resize(img, img, cv::Size(16, 64));
        scalingFactor = 2;
    }
    else {
        cv::resize(img, img, cv::Size(32, 32));
        scalingFactor = 1;
    }
    
    //cv::resize(img, img, cv::Size(32, 32));
    //scalingFactor = 1;

    //cv::medianBlur(img, img, 5);

    // Display the resized image
    if (displayImgs) {
        cv::namedWindow("Display Image", cv::WINDOW_NORMAL );
        cv::imshow("Display Image", img);
        waitKey(0);
    }

    // Compute Sobel derivatives in the x and y directions
    cv::Sobel(img, gx, CV_32F, 1, 0);
    cv::Sobel(img, gy, CV_32F, 0, 1);

    // Convert the derivatives to polar coordinates 
    cv::cartToPolar(gx, gy, magnitude, angle);

    // Quantized values generated by magnitude, angle, and the number of bins
    arma::umat bins = umat(img.rows, img.cols, fill::zeros);

    for (int i = 0; i < bins.n_rows; i++) {
        for (int j = 0; j < bins.n_cols; j++) {
            // Quantize, but first convert to Cartesian
            bins(i, j) = (int) ((bin_n * angle.at<float>(i, j)) / 
                (2 * datum::pi)); 
            // Could be replaced with fancy constructors
        }
    }   

    // Result array of length 64
    arma::umat result = umat(64, 1, fill::zeros);

    // Array that holds magnitudes; Note that dimensions depend on scaling 
    // scaling factor defined above
    arma::fmat magCells = fmat(32 * scalingFactor, 32 / scalingFactor, 
    	fill::zeros);

    // Used to indicate starting points for iterating over the magCells
    int rowsIndex = 0, colsIndex = 0;

    for (int index = 0; index < 4; index++) { 
        // Current histogram will be a length-16 vector
        arma::fmat currentHist = fmat(16, 1, fill::zeros);

        // Taking the integers 0, 1, 2, and 3 (mod 2) and their values upon
        // integer divison by 2 gives an easy way to reduce loop usage and 
        // code length
        rowsIndex = (magCells.n_rows / 2) * (index % 2);
        colsIndex = (magCells.n_cols / 2) * (index / 2);

        for (int i = rowsIndex; i < rowsIndex + (magCells.n_rows / 2); i++) {
            for (int j = colsIndex; j < colsIndex + (magCells.n_cols / 2); j++) {
                // Mimics numpy's bincount function with bins as the array,
                // magnitudes as the weights, and at least 16 bins
                currentHist(bins(i, j), 0) +=  magnitude.at<float>(i, j);
            }
        }

        // Push the current histogram into the result one
        for (int i = 16 * index; i < 16 * (index + 1); i++) {
            result(i, 0) = currentHist(i % 16, 0);
        }
    }

    return result;
}

// Finds the contours in the thresholded image
vector< arma::umat > analyzeContours(cv::Mat img, vector< arma::imat >& parseInfo, 
	bool displayImgs = false) {
	cout << "Analyzing contours" << endl;
    // Initialization

    float imgArea = img.rows * img.cols;
    vector< vector<Point> > contours;

    // To be returned and passed to SVM
    vector< arma::umat > validContours;

    cv::Mat img1 = img.clone();

    cv::Mat imgMean;
    cv::Mat imgStdDev;
    cv::meanStdDev(img1, imgMean, imgStdDev);

    // Find the contours
    cv::findContours(img, contours, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);

    // Vector to hold the bounding rectangles
    vector<Rect> validRectangles(contours.size());

    // Initialize variables to be used later
    cv::Rect temp;
    float currArea;
    float ratio;
    int counter = 0;
    cv::Mat mask;
    Scalar contourMean;

    // Iterate over contours
    for (int i = 0; i < contours.size(); i++) {
        temp = boundingRect(contours[i]);

        // Caluclate each contour's area
        currArea = temp.width * temp.height;
        ratio = currArea / imgArea;


        // If it's big enough
        if (ratio < 2 && ratio > 0.0003 && currArea >= 400) {
            mask = cv::Mat(img1, temp);
            cv::Mat mask2 = cv::Mat(img, temp);
            contourMean = cv::mean(mask);

            float intensityRatio = contourMean[0] / imgMean.at<double>(0);
            if (intensityRatio < 0.95 && (intensityRatio / currArea < 0.0003) ) {
                validContours.push_back(ComputeHOG(mask, displayImgs));
                //arma::imat tempArr = {-1, temp.x, temp.y, temp.width, temp.height};
               	parseInfo.push_back({-1, temp.x, temp.y, temp.width, temp.height, -1});
                counter++;
            } else {
                //cout << intensityRatio / currArea << endl;
                //cv::namedWindow("Display Image", cv::WINDOW_NORMAL );
                //cv::imshow("Display Image", mask);
                //waitKey(0);
            }
        }
    }

    return validContours;
}

// Loads and evaluates the SVM on inputMat
// Predictions are returned in outputMat
cv::Mat predict(cv::Mat inputMat, cv::Mat outputMat) {
	// Setting up SVM
	CvSVMParams params;
    params.svm_type = CvSVM::C_SVC;
    params.kernel_type = CvSVM::LINEAR;
    params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);

    // Loading
    CvSVM SVM;
    SVM.load("svm_data.dat");

    // Predictions
    SVM.predict(inputMat, outputMat);

    return outputMat;
}


// Compares the x values of the contours' top-left corners
// If those are equal, determine which one ends first and put that first
// Note that both imats should be elements of parseInfo
bool compareHoriz(arma::imat a, arma::imat b) {
    if (a[1] == b[1]) {
        return (a[1] + a[3]) < (b[1] + b[3]);
    }
    return a[1] < b[1];
}

// Checks if a contour is in the main row 
bool isInMainRow(int mainRowStart, int mainRowEnd, int contourStart, int contourEnd, int& diff) {

    if ( (mainRowStart > contourStart) && (mainRowEnd < contourEnd) ) { // If the contour contains the entire main row
        return true; // Accept it
    }

    if (contourStart < mainRowStart) {
        diff += mainRowStart - contourStart;
    }
    if (contourEnd > mainRowEnd) {
        diff += contourEnd - mainRowEnd;
    }

    //cout << "Diff: " << diff << endl;

    if (diff > 0.4 * (contourEnd - contourStart)) {
        return false;
    }
    return true;
}


int findRow(vector< arma::imat >& rows, vector< arma::imat >& parseInfo, int index, 
    vector< string >& result, int& rowCounter) {

    /*
    cout << "Printing result: " << endl;
    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
    }
    cout << endl;*/

    string temp = "";

    arma::imat contour = parseInfo[index];

    //cout << "Symbol: " << contour[0] << endl;

    for (int i = 0; i < rows.size(); i++) {
        //cout << "Main";
        int mainDiff = 0;
        bool contained = isInMainRow(rows[i][4], rows[i][5], contour[2], contour[2] + contour[4], mainDiff);
        if (contained) {
            cout << "Main" << endl;
            parseInfo[index][5] = i;

            // Go through the characters and choose the one that relates to this
            for (int j = 0; j < parseInfo.size(); j++) {
                if (parseInfo[j][5] == i) {
                    temp += to_string(parseInfo[j][0]) + " ";
                    parseInfo[j][5] = -1;
                    //cout << "Temp: " << temp << endl;
                }
            }

            // Need to iterate over and close all rows that relate to this

            int indexOfLinked = -1;

            // Iterate over all other rows and see if any were above/below this
            for (int j = 0; j < rows.size(); j++) {
                //cout << rows[j] << endl;
                if (rows[j][1] == i) {
                    for (int k = 0; k < parseInfo.size(); k++) {
                        if (parseInfo[k][5] == rows[j][0]) {
                            result[rows[j][1]] += "^" + to_string(parseInfo[k][0]) + " ";
                            parseInfo[k][5] = -1;
                            indexOfLinked = j;
                            //cout << "Temp: " << temp << endl;
                        }
                    }
                }
            }
            if (indexOfLinked != -1) {
                rows.erase(rows.begin() + indexOfLinked);
            }
            result.push_back(temp);
            return i;
        }
    }

    // Check if it's above
    for (int i = 0; i < rows.size(); i++) {
        int aboveDiff = 0, belowDiff = 0;

        bool containedAbove = isInMainRow(rows[i][3], rows[i][4], contour[2], contour[2] + contour[4], aboveDiff);
        bool containedBelow = isInMainRow(rows[i][5], rows[i][6], contour[2], contour[2] + contour[4], belowDiff);

        //cout << "Above" << aboveDiff << endl;
        //cout << "Below" << belowDiff << endl;

        if (aboveDiff < belowDiff) {
            cout << "Above" << endl;

            // Add a new row with the same above limit
            // but a main row in the middle 1/3 of the previous row's 'above' zone
            rows.push_back( {rowCounter, i, -1, rows[i][3], 
                (rows[i][4] - rows[i][3]) / 3, 
                2 * (rows[i][4] - rows[i][3]) / 3,
                rows[i][4]
            } );
            rowCounter++;
            parseInfo[index][5] = rowCounter - 1;

            //cout << "i: " << i << ", " << parseInfo[index][5] << endl;

            return rowCounter - 1;
        }
        if (belowDiff < aboveDiff) {
            cout << "Below" << endl;
            parseInfo[index][5] = i;

            // TODO: COPY CODE FROM ABOVE
            return i;
        }
        /*
        int contourMean = contour[2] + contour[4] / 2;
        int rowMean = (rows[i][4] + rows[i][5]) / 2;

        if (contourMean < rowMean) {
            cout << "Above" << endl;
            // Create a new arma::imat
            rows.push_back( {rows.size(), i, -1, 
                -1, } );
            return i;
        } else if (contourMean > rowMean) {
            cout << "Below" << endl;
            return i;
        }
        */
    }
}

int main(int argc, char** argv) {
	// Why not time the whole thing?
	arma::wall_clock timer;
	timer.tic();

	// Read in the image in grayscale
	cv::Mat image = cv::imread(argv[1], 0);

	// Apply threshold
	cv::Mat threshImage = preProcess(image, false);

	// Create vector containg location + class info
    // Each element contains these values (in this order): 
    // class, x, y, width, height, row
    // Note that x, y are for the top left corner of the image
	vector< arma::imat > parseInfo;

	// Compute and describe contours
	vector< arma::umat > contours = analyzeContours(threshImage, parseInfo, false);

	// Pass the contours into an array of floats
	float contourArray[contours.size()][64];
	for (int i = 0; i < contours.size(); i++) {
        for (int j = 0; j < 64; j++) {
            contourArray[i][j] = contours[i][j];
        }
    }

    // Create the cv::Mats for the SVM
    cv::Mat inputMat(contours.size(), 64, CV_32FC1, contourArray);
    cv::Mat outputMat(contours.size(), 1, CV_32FC1, 0);

    // Predict using SVM
    outputMat = predict(inputMat, outputMat);

    for (int i = 0; i < contours.size(); i++) {
        parseInfo[i][0] = outputMat.at<float>(i, 0);
        //cout << parseInfo[i] << endl;
    }

    // Sort horizontally
    sort(parseInfo.begin(), parseInfo.end(), compareHoriz);

    // Print result
    /*
    for (int i = 0; i < parseInfo.size(); i++) {
        cout << parseInfo[i] << endl;
    } */   

    // Compute the middle 1/3 of the image
    // Used later in parsing
    int mainRowStart = threshImage.rows / 3;
    int mainRowEnd = 2 * threshImage.rows / 3;

    // Rows contains values in the order
    // id, above(index), below(index), start of above, start of main, end of main, end of below
    vector< arma::imat > rows;
    rows.push_back( {0, -1, -1, 0, mainRowStart, mainRowEnd, threshImage.rows} );
    int rowCounter = 1;
    
    vector< string > result;

    // Iterate over things and check if they're in the main row
    for (int i = 0; i < parseInfo.size(); i++) {
        //bool inMain = isInMainRow(mainRowStart, mainRowEnd, parseInfo[i][2], parseInfo[i][2] + parseInfo[i][4]);
        int index = findRow(rows, parseInfo, i, result, rowCounter);


        cout << "Symbols\n" << endl;
        for (int i = 0; i < parseInfo.size(); i++) {
            cout << parseInfo[i] << endl;
        }
        //cout << "Vector Index, Row Index: " << i << ", " << index << endl;
    }

    /**
    // Need to apply checks to the final element
    if (result.size() != parseInfo.size()) {

        for (int i = 0; i < rows.size(); i++) {
        // Iterate over all other rows and see if any were above/below this
            for (int j = 0; j < rows.size(); j++) {
                //cout << rows[j] << endl;
                if (rows[j][1] == i) {
                    //cout << "Found a row at " << j << endl;
                    cout << "Rows: " << rows[j] << endl;
                    for (int k = 0; k < parseInfo.size(); k++) {
                        if (parseInfo[k][5] == rows[j][0]) {
                            cout << "Found a matching symbol at " << k << endl;
                            cout << rows[j][1] << endl;
                            result[rowCounter - 1] += "^" + to_string(parseInfo[k][0]) + " ";
                            parseInfo[k][5] = -1;
                            //cout << "Temp: " << temp << endl;
                        }
                    }

                }
            } 
        }
    }*/

    /* 
    cout << "Rows\n" << endl;
    for (int i = 0; i < rows.size(); i++) {
        cout << rows[i] << endl;
    }

    cout << "Symbols\n" << endl;
    for (int i = 0; i < parseInfo.size(); i++) {
        cout << parseInfo[i] << endl;
    }*/
    

    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
    }
    cout << endl;

    // Display time taken
	cout << timer.toc() << endl;

	// End
	return 0;
}